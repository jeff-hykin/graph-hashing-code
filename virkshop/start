#!/usr/bin/env sh
"\"",` $(echo --% '
)" > $null <# ${/* ' >/dev/null )` 2>/dev/null; deno_version="1.20.3"; deno_install="$HOME/.deno/$deno_version";deno="$deno_install/bin/deno"; filepath="$deno"; has () { [ ! -z "$(command -v "unzip")" ]; } ; if [ ! -f "$filepath" ] || [ ! -r "$filepath" ] || [ ! -x "$filepath" ]; then if ! has unzip; then could_auto_install="true"; if has apt-get; then if has brew; then could_auto_install="false"; else if ! brew install unzip; then could_auto_install="false"; fi; fi; else if [ "$(whoami)" = "root" ]; then if ! apt-get install unzip -y; then could_auto_install="false"; fi; elif [ -n "$(command -v "sudo")" ]; then echo "Can I install unzip for you? (its required for this command to work)";read ANSWER;echo; if [ ! "$ANSWER" =~ ^[Yy] ]; then could_auto_install="false"; else if ! sudo apt-get install unzip -y; then could_auto_install="false"; fi; fi; elif has doas; then echo "Can I install unzip for you? (its required for this command to work)";read ANSWER;echo; if [ ! "$ANSWER" =~ ^[Yy] ]; then could_auto_install="false"; else if ! doas apt-get install unzip -y; then could_auto_install="false"; fi; fi; else could_auto_install="false"; fi; fi; fi; if [ "$could_auto_install" = "false" ]; then echo "";echo "So I couldn't find an 'unzip' command";echo "And I tried to auto install it, but it seems that failed";echo "(This script needs unzip and either curl or wget)";echo "Please install the unzip command manually then re-run this script";exit 1; fi; if [ "$OS" = "Windows_NT" ]; then target="x86_64-pc-windows-msvc"; else :; case $(uname -sm) in "Darwin x86_64") target="x86_64-apple-darwin" ;; "Darwin arm64") target="aarch64-apple-darwin" ;; *) target="x86_64-unknown-linux-gnu" ;; esac; fi; deno_uri="https://github.com/denoland/deno/releases/download/v$deno_version/deno-$target.zip"; bin_dir="$deno_install/bin"; exe="$bin_dir/deno"; if [ ! -d "$bin_dir" ]; then mkdir -p "$bin_dir"; fi; if has curl; then curl --fail --location --progress-bar --output "$exe.zip" "$deno_uri"; elif has curl ; then wget --output-document="$exe.zip" "$deno_uri"; else echo "Howdy! I looked for the 'curl' and for 'wget' commands but I didn't see either of them."; echo "Please install one of them"; echo "Otherwise I have no way to install the missing deno version needed to run this code"; fi; unzip -d "$bin_dir" -o "$exe.zip"; chmod +x "$exe"; rm "$exe.zip"; fi; "$deno" run -q -A "$0" "$@"; exit $? ; #>; $deno_version = "1.19.0"; $env:DENO_INSTALL = "${HOME}/.deno/${deno_version}"; $deno = "${env:DENO_INSTALL}/bin/deno"; if (-not(Test-Path -Path "${deno}" -PathType Leaf)) { $v="${deno_version}"; iwr https://deno.land/x/install/install.ps1 -useb | iex; }; & "${deno}" run -q -A "${PSCommandPath}" @args; Exit $LastExitCode
# */0}`;

// 
// 
// What is this file doing?
// 
// 
    // 1. trying to install nix
    // 2. using nix to install the environment
    // 3. launching the environment as soon as possible

import { OperatingSystem } from "https://deno.land/x/quickr@0.3.36/main/operating_system.js"
import { FileSystem } from "https://deno.land/x/quickr@0.3.36/main/file_system.js"
import { run, hasCommand, throwIfFails, zipInto, mergeInto, returnAsString, Timeout, Env, Cwd, Stdin, Stdout, Stderr, Out, Overwrite, AppendTo } from "https://deno.land/x/quickr@0.3.36/main/run.js"
import { Console, clearStylesFrom, black, white, red, green, blue, yellow, cyan, magenta, lightBlack, lightWhite, lightRed, lightGreen, lightBlue, lightYellow, lightMagenta, lightCyan, blackBackground, whiteBackground, redBackground, greenBackground, blueBackground, yellowBackground, magentaBackground, cyanBackground, lightBlackBackground, lightRedBackground, lightGreenBackground, lightYellowBackground, lightBlueBackground, lightMagentaBackground, lightCyanBackground, lightWhiteBackground, bold, reset, dim, italic, underline, inverse, hidden, strikethrough, visible, gray, grey, lightGray, lightGrey, grayBackground, greyBackground, lightGrayBackground, lightGreyBackground, } from "https://deno.land/x/quickr@0.3.36/main/console.js"
import { move as moveAndRename } from "https://deno.land/std@0.133.0/fs/mod.ts"

// 
// virkshop object
// 
    const virkshop = Object.defineProperties(
        {
            name: FileSystem.basename(FileSystem.thisFolder),
            pathTo: Object.defineProperties(
                {
                    project: FileSystem.makeAbsolutePath(FileSystem.parentPath(FileSystem.thisFolder)), // subject to change within this file
                    realHome: Console.env.HOME,
                },
                {
                    virkshop: { get() { return `${virkshop.pathTo.project}/${virkshop.name}/` }},
                    settings: { get() { return `${virkshop.pathTo.virkshop}/settings` }},
                    fakeHome: { get() { return `${virkshop.pathTo.virkshop}/temporary/long_term/home` }},
                    virkshopOptions: { get() { return `${virkshop.pathTo.settings}/virkshop/options.json` }},
                }
            ),
            structure: {
                specialMixinFolders: [
                    'commands',
                    'documentation',
                    'events',
                    'home',
                    'settings'
                ],
            }
        },
        {
            folder:      { get() { return virkshop.pathTo.virkshop } }, // alias
            projectName: { get() { return FileSystem.basename(virkshop.pathTo.project)   } },
            options: { get() {
                return JSON.parse(Deno.readTextFileSync(virkshop.pathTo.virkshopOptions))
            }}
        },
    )

// 
// main
// 
    await installNix()
    await sourceNixSetup()
    await enterVirkshop()

// 
// 
// details
// 
// 
    async function installNix() {
        const nixScriptLocalCopy = `
        #!/bin/sh

            # This script installs the Nix package manager on your system by
            # downloading a binary distribution and running its installer script
            # (which in turn creates and populates /nix).

            { # Prevent execution if this script was only partially downloaded
            oops() {
                echo "$0:" "$@" >&2
                exit 1
            }

            umask 0022

            tmpDir="$(mktemp -d -t nix-binary-tarball-unpack.XXXXXXXXXX || \
                    oops "Can't create temporary directory for downloading the Nix binary tarball")"
            cleanup() {
                rm -rf "$tmpDir"
            }
            trap cleanup EXIT INT QUIT TERM

            require_util() {
                command -v "$1" > /dev/null 2>&1 ||
                    oops "you do not have '$1' installed, which I need to $2"
            }

            case "$(uname -s).$(uname -m)" in
                Linux.x86_64) system=x86_64-linux; hash=0c8a432993d06e4d882ad48cde81d9bef23842cf6d7432cd93ef1a99c8d4ef43;;
                Linux.i?86) system=i686-linux; hash=b6e100a704065728ce10408df3ccb2b97c68e4aa033efe5ec9c6d3346f98f011;;
                Linux.aarch64) system=aarch64-linux; hash=0b35f0d3b480e15ca4bf57ee0d90c5dd209f8bf6ab0c429a2e4aca6565b9d9a6;;
                Darwin.x86_64) system=x86_64-darwin; hash=1da9492d6ea1d0ae470df5aed61897f4e3166360a510eb4b5755b1bfb5128177;;
                *) oops "sorry, there is no binary distribution of Nix for your platform";;
            esac

            url="https://releases.nixos.org/nix/nix-2.3.8/nix-2.3.8-$system.tar.xz"

            tarball="$tmpDir/$(basename "$tmpDir/nix-2.3.8-$system.tar.xz")"

            require_util curl "download the binary tarball"
            require_util tar "unpack the binary tarball"
            if [ "$(uname -s)" != "Darwin" ]; then
                require_util xz "unpack the binary tarball"
            fi

            echo "downloading Nix 2.3.8 binary tarball for $system from '$url' to '$tmpDir'..."
            curl -L "$url" -o "$tarball" || oops "failed to download '$url'"

            if command -v sha256sum > /dev/null 2>&1; then
                hash2="$(sha256sum -b "$tarball" | cut -c1-64)"
            elif command -v shasum > /dev/null 2>&1; then
                hash2="$(shasum -a 256 -b "$tarball" | cut -c1-64)"
            elif command -v openssl > /dev/null 2>&1; then
                hash2="$(openssl dgst -r -sha256 "$tarball" | cut -c1-64)"
            else
                oops "cannot verify the SHA-256 hash of '$url'; you need one of 'shasum', 'sha256sum', or 'openssl'"
            fi

            if [ "$hash" != "$hash2" ]; then
                oops "SHA-256 hash mismatch in '$url'; expected $hash, got $hash2"
            fi

            unpack=$tmpDir/unpack
            mkdir -p "$unpack"
            tar -xJf "$tarball" -C "$unpack" || oops "failed to unpack '$url'"

            script=$(echo "$unpack"/*/install)

            [ -e "$script" ] || oops "installation script is missing from the binary tarball!"
            "$script" "$@"

            } # End of wrapping

        `

        if (OperatingSystem.commonChecks.isWindows) {
            throw Error(`\n\nWindows isn't directly supported, but if you install WSL then it should work.\nHere's a tutorial link for installing WSL Ubuntu: https://www.youtube.com/watch?v=EwRVswCtmX4\n\n`)
            // TODO: auto check for WSL and if it's available, try to automatically enter WSL and run this script again inside of it
        }

        // 
        // fix the windows WSL mkfifo problem
        // 
        const mountCInfo = await FileSystem.info('/mnt/c')
        if (mountCInfo.isFolder) {
            // 
            // check for mounting with metadata
            // 

            // check if metadata not enabled
            const result = await run("mount", "-l", Stdout(returnAsString))
            if (!result.match(/C: on \/mnt\/c.*metadata/)) {
                console.log('__________________________________________________________________________________')
                console.log('|                                                                                |')
                console.log('|  Howdy!                                                                        |')
                console.log('|                                                                                |')
                console.log('|  Looks like there`s a metadata hiccup/problem. It seems you`re using WSL       |')
                console.log('|  Sadly, for some reason, WSL doesn`t (by default) support many features of the |')
                console.log('|  linux file system. And For some reason, adding that support requires          |')
                console.log('|  re-mounting the C drive (within WSL) with metadata enabled.                   |')
                console.log('|                                                                                |')
                console.log('|  I`ll run the command automatically, but if you don`t want to put              |')
                console.log('|  your password in, cancel this (CTRL+C) and run the following yourself:        |')
                console.log('|                                                                                |')
                console.log('       cd                                                                         ')
                console.log('       sudo umount /mnt/c && sudo mount -t drvfs C: /mnt/c -o metadata            ')
                console.log('       cd -                                                                       ')
                console.log('|                                                                                |')
                console.log('|  Then re-run this script                                                       |')
                console.log('|  You can read more about this problem here if you like:                        |')
                console.log('|  https://devblogs.microsoft.com/commandline/chmod-chown-wsl-improvements/      |')
                console.log('|                                                                                |')
                console.log('----------------------------------------------------------------------------------')
                console.log('')
                await Console.askFor.confirmation('Continue?')
                // this means we need to unmount and remount with metadata enabled
                const originalDirectory = FileSystem.pwd
                Deno.chdir(FileSystem.home)
                var { success } = await run("sudo", "umount", "/mnt/c").outcome
                var { success } = success ? await run("sudo", "mount", "-t", "drvfs", "C:", "/mnt/c", "-o", "metadata").outcome : { success }
                // TODO: add a check for an error ^here
                if (!success) {
                    console.error('\nOne of the commands didn`t work :/\ntry running the commands mentioned above manually\n')
                    await Console.askFor.confirmation('Continue anyways?')
                }
                
                // go back
                Deno.chdir(originalDirectory)
            }
            
            // 
            // check if project is inside the windows C drive
            // 
            if (FileSystem.thisFolder.match(/^\/mnt\/c/)) {
                console.log('__________________________________________________________________________________')
                console.log('|                                                                                |')
                console.log('|  Howdy!                                                                        |')
                console.log('|                                                                                |')
                console.log('|  Looks like your project is saved in the windows file system                   |')
                console.log('|  (instead of the Linux/WSL file system)                                        |')
                console.log('|                                                                                |')
                console.log('|  This is a bit of a problem since the file systems of                          |')
                console.log('|  Linux/Mac/Android/ChromeBook/OpenBSD/etc have many features                   |')
                console.log('|  that the windows file system does not have.                                   |')
                console.log('|                                                                                |')
                console.log('|  Would it be okay if I move this project?                                      |')
                console.log('|      I`ll create a shortcut to it so you can still find it.                    |')
                console.log('|      https://devblogs.microsoft.com/commandline/chmod-chown-wsl-improvements/  |')
                console.log('|                                                                                |')
                console.log('----------------------------------------------------------------------------------')
                const answeredYes = await Console.askFor.yesNo("[y/n]")
                if (!answeredYes) {
                    console.log()
                    console.log('okay, in that case just re-run this command whenever')
                    console.log('you have moved the project to the linux file system')
                    console.log('    ')
                    console.log('    if youre confused about what that^ means')
                    console.log('    take a look at the "documentation" folder (inside of this project folder)')
                    console.log()
                    Deno.exit()
                } else {
                    // 
                    // where to move project
                    // 
                    let newProjectLocation, answeredYes
                    while (true) {
                        newProjectLocation = `${FileSystem.home}/repos/${projectName}`
                        answeredYes = await Console.askFor.yesNo(`Is it okay if I move the project to: ${yellow`${newProjectLocation}`}?`)
                        if (!answeredYes) {
                            console.log()
                            newProjectLocation = await Console.askFor.line("Okay what folder should I move it to? ")
                        } else {
                            break
                        }
                    }
                    // 
                    // move the project
                    // 
                    await move({
                        item: virkshop.pathTo.project,
                        newParentFolder: newProjectLocation,
                    })
                    // create a link from the old location to the new location so they can still access the project
                    await relativeLink({
                        existingItem: newProjectLocation,
                        newItem: virkshop.pathTo.project,
                    })
                    virkshop.pathTo.project = newProjectLocation
                }
            }
        }

        // 
        // if nix not installed
        // 
        if (!await hasCommand('nix')) {
            console.log("|------------------------------------------------------|")
            console.log("|                                                      |")
            console.log("|    I'll try to install nix for you                   |")
            console.log("|    (since I don't see nix yet)                       |")
            console.log("|                                                      |")
            console.log("|------------------------------------------------------|")
            console.log("")
            // check if root user
            const username = await run`whoami ${Stdout(returnAsString)}`
            if (username == "root") {
                console.log("looks like you're logged in as root")
                console.log("Sadly nix can't install on the root user :/ ")
                console.log("please use a regular user, then re-run this script")
                Deno.exit()
                // TODO: check the available users for whoever is trying to setup as root
            }

            if (OperatingSystem.commonChecks.isMac) {
                const version = await run`sw_vers -productVersion ${Stdout(returnAsString)}`
                const versionMatch = version.match(/([0-9]+)\.([0-9]+)\.([0-9]+)?/g)
                let [majorVersion, minorVersion, patchVersion] = [ 12, 4, 0 ]
                if (!versionMatch) {
                    console.log(red`There was a bit of a problem :/                                         `)
                    console.log(`---------------------------------------------------------------------------`)
                    console.log(`     I ran this command:  sw_vers -productVersion                          `)
                    console.log(`                                                                           `)
                    console.log(`     Which should return the MacOS version                                 `)
                    console.log(`     And it should be in the format [number].[number].[number]             `)
                    console.log(`     But it appears this is not the case, instead it returned this:        `)
                    console.log(`         ${version}                                                        `)
                    console.log(`     And this script doesn't know how to handle that                       `)
                    console.log(`     Report the issue to the virkshop github repo (google)                 `)
                    console.log(`     And I'll get it fixed ASAP                                            `)
                    console.log(`---------------------------------------------------------------------------`)
                    console.log(``)
                    await Console.askFor.confirmation(`Continue anyways? (I'll assume you have MacOS Monterey)`)
                } else {
                    majorVersion = versionMatch[1]-0
                    minorVersion = versionMatch[2]-0
                    patchVersion = versionMatch[3]-0 || 0 // convert NaN to 0 if needed
                }
                
                // Catalina, Big Sur, Monterey, and beyond
                if (majorVersion > 10 || (majorVersion == 10 && minorVersion >= 15)) {
                    var { success } = await run`sh -c ${'sh <(curl -Lk https://releases.nixos.org/nix/nix-2.3.8/install) --darwin-use-unencrypted-nix-store-volume'}`
                // Older than Catalina (Mojave, High Siera, Siera, Yosemite, Mavericks, etc)
                } else {
                    var { success } = await run`curl -Lk https://releases.nixos.org/nix/nix-2.3.8/install | sh -s -- --daemon`
                }

            } else if (OperatingSystem.commonChecks.isLinux) {
                var nixScript
                try {
                    nixScript = await curlString`https://releases.nixos.org/nix/nix-2.3.8/install`
                // if host is down, or fails for some other reason, use the locally stored copy (which may be out of date)
                } catch (error) {
                    nixScript = nixScriptLocalCopy
                }

                // prefer single-user install (no groups/users, no systemd need, and seems to not need shell reload)
                await run("sh", "-s", Stdin(nixScript))

                // alternative multi-user install (encouraged by nixpkgs)
                // check if systemd exists
                // if pidof systemd
                // then
                //     # multi-user install if systemd exists
                //     curl -Lk https://releases.nixos.org/nix/nix-2.3.8/install | sh -s -- --daemon
                // else
                //     # single-user install if systemd exists
                //     curl -L https://releases.nixos.org/nix/nix-2.3.8/install | sh
                // fi
            }
        }

        const nixStoreFolderInfo = await FileSystem.info(`/nix/store`)
        if (!nixStoreFolderInfo.isFolder) {
            console.log(red`There was a bit of a problem :/                                         `)
            console.log(`---------------------------------------------------------------------------`)
            console.log(`     Something is wrong with the nix install since /nix/store              `)
            console.log(`     is not a folder. It could be a simple fix, so checkout                `)
            console.log(`     https://nixos.org/manual/nix/stable/#chap-installation                `)
            console.log(`     and see if you can follow the normal instructions for installing nix  `)
            console.log(`---------------------------------------------------------------------------`)
            console.log(``)
            await Console.askFor.confirmation('Continue without nix? (basically everything will break)')
        }
    }

    async function sourceNixSetup() {
        // 
        // add nix certificate file
        // 
            // make sure MacOS has cert files
            const certFilePath = "/etc/ssl/certs/ca-certificates.crt"
            const certParentFolder = FileSystem.parentPath(certFilePath)
            const certFileInfo = await FileSystem.info(certFilePath)
            if (!certFileInfo.isFile) {
                const certParentFolderInfo = await FileSystem.info(certFilePath)
                if (!certParentFolderInfo.isFolder) {
                    console.log("")
                    console.log("Creating folder for web certificates because MacOS doesn't follow other OS's")
                    console.log("")
                    await run`sudo mkdir -p ${FileSystem.parentPath(certFilePath)}`
                }
                console.log("")
                console.log("Creating certificate file because MacOS doesn't follow other OS's")
                console.log("")
                await run`sudo security export -t certs -f pemseq -k /System/Library/Keychains/SystemRootCertificates.keychain -o /etc/ssl/certs/ca-certificates.crt`
                // TODO: add a check encase /System/Library/Keychains/SystemRootCertificates.keychain doesnt exist
            }
            
            // 
            // test and check
            // 
            const possibleCertificateLocations = [
                "/etc/ssl/certs/ca-certificates.crt", // NixOS, Ubuntu, Debian, Gentoo, Arch
                "/etc/ssl/ca-bundle.pem",             // openSUSE Tumbleweed
                "/etc/ssl/certs/ca-bundle.crt",       // Old NixOS
                "/etc/pki/tls/certs/ca-bundle.crt",   // Fedora, CentOS
            ]
            for (const eachCertificatePath of possibleCertificateLocations) {
                const file = await FileSystem.info(eachCertificatePath)
                if (file.isFile) {
                    Console.env.NIX_SSL_CERT_FILE = eachCertificatePath
                }
            }
        // 
        // nix profiles
        // 
            Console.env.NIX_PROFILES = `/nix/var/nix/profiles/default ${OperatingSystem.home}/.nix-profile`
        // 
        // nix path
        // 
            Console.env.NIX_PATH = "nixpkgs=/nix/var/nix/profiles/per-user/root/channels/nixpkgs:/nix/var/nix/profiles/per-user/root/channels"
        // 
        // add nix commands
        // 
            Console.env.PATH = `${Console.env.PATH}:${OperatingSystem.home}/.nix-profile/bin/:/nix/var/nix/profiles/default/bin/`
    }

    // 
    // 
    // Nix should now be installed => Enter the virkshop!
    // 
    // 
    async function enterVirkshop() {
        // summary
            // unlike the start command, this one has access to a standardized version of deno and bash
            // similar to the previous command, it has access to external environment variables
        // what this script does:
            // phase 0: create folder structure (establish linked files/folders, clean broken links)
            // phase 1: import all the .js files of mixins (they can access external ENV vars, and dont have the full env)
            // phase 2: start shell/virkshop, which will run all the zsh scripts
        
        // setup the env
        Console.env.VIRKSHOP_FOLDER = virkshop.pathTo.project

        function camelCase(str) {
            const addedSeperator = str.replace(/([a-z0-9])([A-Z])/g, "$1_$2").replace(/[^a-zA-Z0-9 _.-]/,"_").toLowerCase()
            const words = addedSeperator.split(/[ _.-]+/g)
            const capatalizedWords = words.map(each=>each.replace(/^\w/, (group0)=>group0.toUpperCase()))
            // make the first one lowercase
            capatalizedWords[0] = capatalizedWords[0].toLowerCase()
            return capatalizedWords.join('')
        }

        const varnamePattern = /^[a-zA-Z_][a-zA-Z0-9_]*$/
        async function objectifyFolder(folder) {
            const object = {}
            for (const each of await FileSystem.listItemsIn(folder)) {
                // ignore many file names for future compatibility
                if (!each.basename.match(varnamePattern)) {
                    continue
                }
                // if file, just read it
                if (each.isFile) {
                    object[each.name] = await FileSystem.read(each.path)
                // if its a folder convert it to an object
                } else {
                    object[each.name] = await objectifyFolder(each.path)
                }
            }
        }

        async function recursivelyFileLink({targetFolder, existingFolder}) {
            const target = await FileSystem.info(targetFolder)
            const existing = await FileSystem.info(existingFolder)
            
            const existingItems = await FileSystem.recursivelyListItemsIn(existing)
            for (const existingItem of existingItems) {
                const relativePart = await FileSystem.makeRelativePath({
                    from: existing.path,
                    to: existingItem.path 
                })
                // link the file (creating any folders necessary in the process)
                await relativeLink({
                    existingItem: existingItem.path,
                    newItem: `${target.path}/${relativePart}`,
                })
            }
        }

        async function linkMixinNamespace(path) {
            const mixinName = FileSystem.basename(path)
            for (const eachSpecialFolder of virkshop.structure.specialMixinFolders) { // FIXME: home folder needs to be treated differently
                const mixinFolder                      = `${path}/${eachSpecialFolder}/${mixinName}`
                const commonFolderReservedForThisMixin = `${virkshop.folder}/${eachSpecialFolder}/${mixinName}`

                if (eachSpecialFolder == 'events') {
                    console.debug(`mixinFolder is:`,mixinFolder)
                    console.debug(`commonFolderReservedForThisMixin is:`,commonFolderReservedForThisMixin)
                }
                
                await FileSystem.ensureIsFolder(mixinFolder)
                
                // 
                // create the "namespaced" folder of the file first
                // 
                const namespaceCheck = await FileSystem.info(commonFolderReservedForThisMixin)
                let needToCreateNamespace = false
                if (!namespaceCheck.exists) {
                    needToCreateNamespace = true
                } else if (!namespaceCheck.isSymlink) {
                    if (namespaceCheck.isFolder) {
                        const paths = await FileSystem.listPathsIn(namespaceCheck.path)
                        for (const eachExisting of paths) {
                            console.debug(`eachExisting is:`,eachExisting)
                            await move({
                                item: eachExisting,
                                newParentFolder: mixinFolder,
                                overwrite: true,
                            })
                        }
                    }
                    await FileSystem.remove(commonFolderReservedForThisMixin)
                    needToCreateNamespace = true
                } else {
                    const target = FileSystem.makeAbsolutePath(namespaceCheck.pathToNextTarget)
                    const thisFolder = FileSystem.makeAbsolutePath(mixinFolder)
                    if (target != thisFolder) {
                        await FileSystem.remove(commonFolderReservedForThisMixin)
                        needToCreateNamespace = true
                    }
                }
                // create the commonFolderReservedForThisMixin
                if (needToCreateNamespace) {
                    await relativeLink({
                        existingItem: mixinFolder,
                        newItem: commonFolderReservedForThisMixin
                    })
                }

                

                // // 
                // // create shortcuts within the commonFolderReservedForThisMixin
                // // 
                // // TODO: maybe rethink this
                // const nestedNamespace = `${commonFolder}/${mixinName}/${mixinName}`
                // for (const eachPath of await FileSystem.listPathsIn(nestedNamespace)) {
                //     const relativePart = eachPath.slice(nestedNamespace.length)
                //     const targetLocation = await FileSystem.info(`${commonFolderReservedForThisMixin}/${relativePart}`)
                //     // if hardlink
                //     if (targetLocation.isFile && !targetLocation.isSymlink) {
                //         // assume the user put it there, or that its the plugin's ownership
                //         continue
                //     // if symlink
                //     } else if (targetLocation.isFile) {
                //         // remove broken things
                //         if (targetLocation.isBrokenLink) {
                //             await FileSystem.remove(targetLocation.path)
                //         } else {
                //             const target      = FileSystem.makeAbsolutePath(targetLocation.path)
                //             const currentItem = FileSystem.makeAbsolutePath(eachPath)
                //             if (target == currentItem) {
                //                 // already linked
                //                 continue
                //             } else {
                //                 // linked but to the wrong thing
                //                 // FIXME: add a warning about conflicting items here, and replace the symlink with the warning
                //                 //        note its possible for one to be a file and the other a folder
                //                 continue
                //             }
                //         }
                //     }
                //     const mixinItem = await FileSystem.info(eachPath)
                //     if (mixinItem.isFile) {
                //         // FIXME: this could technically destroy a user-made file by having it as part of the parent path
                        
                //         // make sure it exists by this point
                //         await FileSystem.ensureIsFolder(FileSystem.parent)
                //         // create the shortcut
                //         await relativeLink({
                //             existingItem: mixinItem.path,
                //             newItem: targetLocation.path,
                //         })
                //     }
                //     // TODO: consider another edgecase of mixin item being a file, but existing item being a folder
                // }
            }
        }

        async function linkMixinShortcuts(path) {
            // NOTE: linkMixinNamespace needs to be run for EVERY mixin before shortcuts can run. Otherwise there could be order of operations problems

            const mixinName = FileSystem.basename(path)
            for (const eachSpecialFolder of virkshop.structure.specialMixinFolders) {
                const commonFolder = `${virkshop.folder}/${eachSpecialFolder}`
                const mixinFolder  = `${path}/${eachSpecialFolder}`

                // 
                // add all the shortcut links
                // 
                for (const eachPath of await FileSystem.recursivelyListPathsIn(mixinFolder)) {
                    const relativePart = eachPath.slice(mixinFolder.length)
                    const targetLocation = await FileSystem.info(`${commonFolder}/${relativePart}`)
                    // if hardlink
                    if (targetLocation.isFile && !targetLocation.isSymlink) {
                        // assume the user put it there, or that its the plugin's ownership
                        continue
                    // if symlink
                    } else if (targetLocation.isFile) {
                        // remove broken things
                        if (targetLocation.isBrokenLink) {
                            await FileSystem.remove(targetLocation.path)
                        } else {
                            const target      = FileSystem.makeAbsolutePath(targetLocation.path)
                            const currentItem = FileSystem.makeAbsolutePath(eachPath)
                            if (target == currentItem) {
                                // already linked
                                continue
                            } else {
                                // linked but to the wrong thing
                                // FIXME: add a warning about conflicting items here, and replace the symlink with the warning
                                //        note its possible for one to be a file and the other a folder
                                continue
                            }
                        }
                    }
                    const mixinItem = await FileSystem.info(eachPath)
                    if (mixinItem.isFile) {
                        // FIXME: this could technically destroy a user-made file by having it as part of the parent path
                        
                        // make sure it exists by this point
                        await FileSystem.ensureIsFolder(FileSystem.parentPath(mixinItem.path))
                        // create the shortcut
                        await relativeLink({
                            existingItem: mixinItem.path,
                            newItem: targetLocation.path,
                        })
                    }
                    // TODO: consider another edgecase of mixin item being a file, but existing item being a folder
                }
            }
        }

        async function trigger(eventPath) {
            let promises = []
            const eventPathInfo = await FileSystem.info(eventPath)
            if (eventPathInfo.isFolder) {
                const paths = await FileSystem.recursivelyListPathsIn(eventPath)
                paths.sort()
                // FIXME: sort them numerically
                // FIXME: pad out the 0's to make the numbers equal lengths
                for (const eachPath of paths) {
                    await run`${eachPath}`
                }
            }
        }


        let promises = []

        // 
        // 
        // Phase 0: link everything!
        // 
        //
            // 
            // establish mixins protected namespace
            // 
            // FIXME: problem here with priority, what happens if two extensions write to the same location
            //    SOLUTION! this is just like traits/mixins
            //              instead of using a number priority, put all their stuff under a namespace
            //              then attempt to put it outside the namespace
            //                  if there is a conflict, make the command print out "there is a conflict, please specify if you want the command from __ or __"
            //  new FIXME: the above solution doesnt work for the home folder.
            //             maybe add a message any time a .profile or .rc file is added to the home and explain
            //     possible solution: use the project extension to pick one, which can be a combination (concat or pick one or whatever)
            const mixinPaths = await FileSystem.listPathsIn(`${virkshop.folder}/mixins`)
            // namespace
            for (const eachMixin of mixinPaths) {
                promises.push(linkMixinNamespace(eachMixin) )
            }
            // TODO: purge broken system links more
            
            // let them finish in any order (efficient), but they need to be done before phase 1 starts
            await Promise.all(promises)
            
            // rule1: never overwrite non-symlink files (in commands/ settings/ etc)
            //        hardlink files are presumably created by the user, not a mixin
            // link virkshop folders up-and-out into the project folder
            await Promise.all(Object.entries(virkshop.options.linkToProject).map(async ([whereInProject, whereInVirkshop])=>{
                
                const sourcePath = `${virkshop.pathTo.virkshop}/${whereInVirkshop.replace(/^\$virkshop/,"./")}`
                const target = await FileSystem.info(`${virkshop.pathTo.project}/${whereInProject}`)
                if (target.isBrokenLink) {
                    await FileSystem.remove(target.path)
                }
                // create it, but dont destroy an existing folder (unless its a broken link)
                if (target.isBrokenLink || !target.exists)  {
                    await relativeLink({
                        existingItem: sourcePath,
                        newItem: target.path,
                    })
                }
            }))


        // 
        // Phase 1
        // 
            // 
            // let the mixins set themselves up
            // 
            promises = []
            for (const eachMixinPath of mixinPaths) {
                promises.push(
                    FileSystem.recursivelyListItemsIn(`${eachMixinPath}/events/virkshop/phase_1`).then(
                        async (phase1Items)=>{
                            phase1Items.sort() // FIXME: this is javascript so of course it won't actually sort alpha-numerically
                            for (const eachItem of phase1Items) {
                                // if its not a folder
                                if (!eachItem.isFolder && eachItem.exists) {
                                    await FileSystem.addPermissions({path: eachItem.path, permissions: { owner: {canExecute: true} }})
                                    try {
                                        await run`${eachItem.path}`
                                    } catch (error) {
                                        console.debug(`\n\nWARNING: error while executing phase_1 of ${FileSystem.basename(eachMixinPath)}`,)
                                    }
                                }
                            }
                        }
                    )
                )
            }
            await Promise.all(promises)
            
            // 
            // once theyve created their peices, connect them to the larger outside system
            // 
            
            // shortcuts 
            for (const eachMixin of mixinPaths) {
                await linkMixinShortcuts(eachMixin)
            }

            // 
            // link stuff into fake home
            // 
            await recursivelyFileLink({
                existingFolder: `${virkshop.folder}/home`,
                targetFolder: virkshop.pathTo.fakeHome,
            })

        // 
        // let the .zshrc start Phase 2
        // 
            Console.env.REAL_HOME = Console.env.HOME
            Console.env.PROJECT   = FileSystem.normalize(`${virkshop.folder}/..`)
            Console.env.HOME      = virkshop.pathTo.fakeHome
            // FIXME: these env variables are not going to be passed through
            await run`nix-shell --pure --command zsh`
    }

    async function curlString(url) {
        return  new TextDecoder().decode(
            new Uint8Array(await (await fetch(url)).arrayBuffer())
        )
    }
    
    import * as Path from "https://deno.land/std@0.128.0/path/mod.ts"
    async function move({ item, newParentFolder, newName, overwrite=false, force=true }) {
        // force     => will MOVE other things out of the way until the job is done
        // overwrite => will DELETE things out of the way until the job is done
        
        const oldPath = item.path || item
        const oldName = FileSystem.basename(oldPath)
        const itemInfo = item instanceof Object || await FileSystem.info(oldPath)
        const newPath = `${newParentFolder}/${newName || oldName}`

        console.debug(`oldPath is:`,oldPath)
        console.debug(`newPath is:`,newPath)
        
        // if its a relative-linked item the the relative link will need to be adjusted after the move
        if (itemInfo.isSymlink && !Path.isAbsolute(itemInfo.nextTarget)) {
            const adjustedSymlinkOriginalTarget = `${itemInfo.path}/${itemInfo.nextTarget}`
            await relativeLink({
                existingItem: adjustedSymlinkOriginalTarget,
                newItem: newPath,
                force,
            })
        // normal case, just move
        } else {
            if (force || overwrite) {
                await FileSystem.clearAPathFor(newPath, { overwrite })
            }
            await moveAndRename(item, newPath)
        }

        // FIXME: this doesn't handle the case of symlinks pointing at the file that was just moved (they will just break without warning)
    }

    async function relativeLink({existingItem, newItem, force=true, overwrite=false}) {
        existingItem = (existingItem.path || existingItem).replace(/\/+$/, "") // the replace is to remove trailing slashes, which will cause painful nonsensical errors if not done
        newItem = (newItem.path || newItem).replace(/\/+$/, "") // if given ItemInfo object

        console.debug(`existingItem is:`,existingItem)
        console.debug(`newItem is:`,newItem)
        
        const existingItemDoesntExist = (await Deno.lstat(existingItem).catch(()=>({doesntExist: true}))).doesntExist
        // if the item doesnt exists
        if (existingItemDoesntExist) {
            throw Error(`\nTried to create a relativeLink between existingItem:${existingItem}, newItem:${newItem}\nbut existingItem didn't actually exist`)
        } else {
            if (force || overwrite) {
                await FileSystem.clearAPathFor(newItem, {overwrite})
            }
            const [ folders, name, extension ] = FileSystem.pathPieces(FileSystem.makeAbsolutePath(newItem))
            console.debug(`name is:`,name)
            console.debug(`folders is:`,folders)
            let topDownPath = ``
            for (let eachFolderName of folders) {
                eachFolderName = FileSystem.basename(eachFolderName)
                topDownPath += `/${eachFolderName}`
                console.debug(`topDownPath is:`,topDownPath)
                const info = await FileSystem.info(topDownPath)
                if (info.isSymlink) {
                    // finalTargetPathOf must exist (outside of a targeted race-condition attack) because FileSystem.clearAPathFor ensures each folder exists
                    const absolutePathToIntermediate = await finalTargetOf(info)
                    // remove the path to the syslink folder
                    topDownPath = topDownPath.slice(0, -(eachFolderName.length+1))

                    const relativePath = FileSystem.makeRelativePath({
                        from: topDownPath,
                        to: absolutePathToIntermediate,
                    })
                    console.debug(`relativePath is:`,relativePath)
                    console.debug(`   topDownPath is:`,topDownPath)
                    console.debug(`   absolutePathToIntermediate is:`,absolutePathToIntermediate)
                    // replace it with the real intermediate path
                    topDownPath += `/`+FileSystem.makeRelativePath({
                        from: topDownPath,
                        to: absolutePathToIntermediate,
                    })
                }
            }
            const finalTargetPath = `${topDownPath}/${name}${extension}`
            const pathFromNewToExisting = Path.relative(finalTargetPath, existingItem).replace(/^\.\.\//,"") // all paths should have the "../" at the begining
            console.debug(`finalTargetPath is:`,finalTargetPath)
            console.debug(`pathFromNewToExisting is:`,pathFromNewToExisting)
            return Deno.symlink(
                pathFromNewToExisting,
                finalTargetPath,
            )
        }
    }

    async function finalTargetOf(path) {
        path = (path.path || path) // if given ItemInfo object
        let result = await Deno.lstat(path).catch(()=>({doesntExist: true}))
        if (result.doesntExist) {
            return null
        }
        const pathChain = [ FileSystem.makeAbsolutePath(path) ]
        while (result.isSymlink) {
            console.debug(`pathChain is:`,pathChain)
            // get the path to the target
            const relativeOrAbsolutePath = await Deno.readLink(path)
            if (Path.isAbsolute(relativeOrAbsolutePath)) {
                path = relativeOrAbsolutePath
            } else {
                path = `${FileSystem.parentPath(path)}/${relativeOrAbsolutePath}`
            }
            result = await Deno.lstat(path).catch(()=>({doesntExist: true}))
            // check if target exists
            if (result.doesntExist) {
                return null
            }
            // check for infinite loops (normalizes and makes absolute)
            const absolutePath = FileSystem.makeAbsolutePath(path)
            if (pathChain.includes(absolutePath)) {
                // circular loop of links
                return null
            }
            pathChain.push(absolutePath)
        }
        console.debug(`pathChain is:`,pathChain)
        
        return path
    }