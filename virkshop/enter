#!/usr/bin/env sh
"\"",` $(echo --% '
)" > $null <# ${/* ' >/dev/null )` 2>/dev/null; deno_version="1.20.3"; deno_install="$HOME/.deno/$deno_version";deno="$deno_install/bin/deno"; filepath="$deno"; has () { [ ! -z "$(command -v "unzip")" ]; } ; if [ ! -f "$filepath" ] || [ ! -r "$filepath" ] || [ ! -x "$filepath" ]; then if ! has unzip; then could_auto_install="true"; if has apt-get; then if has brew; then could_auto_install="false"; else if ! brew install unzip; then could_auto_install="false"; fi; fi; else if [ "$(whoami)" = "root" ]; then if ! apt-get install unzip -y; then could_auto_install="false"; fi; elif [ -n "$(command -v "sudo")" ]; then echo "Can I install unzip for you? (its required for this command to work)";read ANSWER;echo; if [ ! "$ANSWER" =~ ^[Yy] ]; then could_auto_install="false"; else if ! sudo apt-get install unzip -y; then could_auto_install="false"; fi; fi; elif has doas; then echo "Can I install unzip for you? (its required for this command to work)";read ANSWER;echo; if [ ! "$ANSWER" =~ ^[Yy] ]; then could_auto_install="false"; else if ! doas apt-get install unzip -y; then could_auto_install="false"; fi; fi; else could_auto_install="false"; fi; fi; fi; if [ "$could_auto_install" = "false" ]; then echo "";echo "So I couldn't find an 'unzip' command";echo "And I tried to auto install it, but it seems that failed";echo "(This script needs unzip and either curl or wget)";echo "Please install the unzip command manually then re-run this script";exit 1; fi; if [ "$OS" = "Windows_NT" ]; then target="x86_64-pc-windows-msvc"; else :; case $(uname -sm) in "Darwin x86_64") target="x86_64-apple-darwin" ;; "Darwin arm64") target="aarch64-apple-darwin" ;; *) target="x86_64-unknown-linux-gnu" ;; esac; fi; deno_uri="https://github.com/denoland/deno/releases/download/v$deno_version/deno-$target.zip"; bin_dir="$deno_install/bin"; exe="$bin_dir/deno"; if [ ! -d "$bin_dir" ]; then mkdir -p "$bin_dir"; fi; if has curl; then curl --fail --location --progress-bar --output "$exe.zip" "$deno_uri"; elif has curl ; then wget --output-document="$exe.zip" "$deno_uri"; else echo "Howdy! I looked for the 'curl' and for 'wget' commands but I didn't see either of them."; echo "Please install one of them"; echo "Otherwise I have no way to install the missing deno version needed to run this code"; fi; unzip -d "$bin_dir" -o "$exe.zip"; chmod +x "$exe"; rm "$exe.zip"; fi; "$deno" run -q -A "$0" "$@"; exit $? ; #>; $deno_version = "1.19.0"; $env:DENO_INSTALL = "${HOME}/.deno/${deno_version}"; $deno = "${env:DENO_INSTALL}/bin/deno"; if (-not(Test-Path -Path "${deno}" -PathType Leaf)) { $v="${deno_version}"; iwr https://deno.land/x/install/install.ps1 -useb | iex; }; & "${deno}" run -q -A "${PSCommandPath}" @args; Exit $LastExitCode
# */0}`;

// 
// 
// What is this file doing?
// 
// 
    // 1. trying to install nix
    // 2. using nix to install the environment
    // 3. launching the environment as soon as possible

import { OperatingSystem } from "https://deno.land/x/quickr@0.4.0/main/operating_system.js"
import { FileSystem } from "https://deno.land/x/quickr@0.4.0/main/file_system.js"
import { run, hasCommand, throwIfFails, zipInto, mergeInto, returnAsString, Timeout, Env, Cwd, Stdin, Stdout, Stderr, Out, Overwrite, AppendTo } from "https://deno.land/x/quickr@0.4.0/main/run.js"
import { Console, clearStylesFrom, black, white, red, green, blue, yellow, cyan, magenta, lightBlack, lightWhite, lightRed, lightGreen, lightBlue, lightYellow, lightMagenta, lightCyan, blackBackground, whiteBackground, redBackground, greenBackground, blueBackground, yellowBackground, magentaBackground, cyanBackground, lightBlackBackground, lightRedBackground, lightGreenBackground, lightYellowBackground, lightBlueBackground, lightMagentaBackground, lightCyanBackground, lightWhiteBackground, bold, reset, dim, italic, underline, inverse, hidden, strikethrough, visible, gray, grey, lightGray, lightGrey, grayBackground, greyBackground, lightGrayBackground, lightGreyBackground, } from "https://deno.land/x/quickr@0.4.0/main/console.js"
import { move as moveAndRename } from "https://deno.land/std@0.133.0/fs/mod.ts"
import * as Path from "https://deno.land/std@0.128.0/path/mod.ts"
import { virkshop } from "./core.js"

// 
// main
// 
    await installNix()
    await sourceNixSetup()
    await enterVirkshop()

// 
// 
// details
// 
// 
    async function installNix() {
        const nixVersion = `nix-2.9.2` // 2.3.8
        const urlSource = `https://releases.nixos.org/nix/nix-${nixVersion}` // "https://releases.nixos.org/nix/nix-2.3.8"
        const nixScriptLocalCopy = `#!/bin/sh

            # This script installs the Nix package manager on your system by
            # downloading a binary distribution and running its installer script
            # (which in turn creates and populates /nix).

            { # Prevent execution if this script was only partially downloaded
            oops() {
                echo "$0:" "$@" >&2
                exit 1
            }

            umask 0022

            tmpDir="$(mktemp -d -t nix-binary-tarball-unpack.XXXXXXXXXX || \\
                    oops "Can't create temporary directory for downloading the Nix binary tarball")"
            cleanup() {
                rm -rf "$tmpDir"
            }
            trap cleanup EXIT INT QUIT TERM

            require_util() {
                command -v "$1" > /dev/null 2>&1 ||
                    oops "you do not have '$1' installed, which I need to $2"
            }

            case "$(uname -s).$(uname -m)" in
                Linux.x86_64)
                    hash=e5fd4e993bc6c565aa0544eec2db6a977e496896f4133002436b1be1d3e9a8f6
                    path=xwn7n573m5m3j4c01dljm0xis1d1l0qq/${nixVersion}-x86_64-linux.tar.xz
                    system=x86_64-linux
                    ;;
                Linux.i?86)
                    hash=d8d6a8a08a40ad0e22491b57402de2212d055e91d3e03fc5cee0db5064319f72
                    path=nz375g80bx5i26gzqfsddiz3b4kk0ghn/${nixVersion}-i686-linux.tar.xz
                    system=i686-linux
                    ;;
                Linux.aarch64)
                    hash=b1bd23a831357e9041a255fd23a7665f51cbd40229773eb7eb66c5b3d3976986
                    path=39wdq7nscrd9jf0dz858s89kwpvqjrv1/${nixVersion}-aarch64-linux.tar.xz
                    system=aarch64-linux
                    ;;
                Linux.armv6l_linux)
                    hash=29c88bd45341eb05c239ad7a51840e57a28749db3cac3432983076018a0df1c5
                    path=zm4i801kcna7530ml0c81girb7m403bi/${nixVersion}-armv6l-linux.tar.xz
                    system=armv6l-linux
                    ;;
                Linux.armv7l_linux)
                    hash=983299e3d1b6fdadc487624d94e66a4e7b268c4acc77707739ef1bb78783a4a4
                    path=bcvm9kkqw4wyycybhsz3ygy0lrja8905/${nixVersion}-armv7l-linux.tar.xz
                    system=armv7l-linux
                    ;;
                Darwin.x86_64)
                    hash=09bbf6c6f75a6cb5073d7360f29168994ed45ef53ee9348f7a452ec7dc31ddf7
                    path=fzalici37aikkxqilzi3qjiq4qr2sllk/${nixVersion}-x86_64-darwin.tar.xz
                    system=x86_64-darwin
                    ;;
                Darwin.arm64|Darwin.aarch64)
                    hash=aa5405f427a94b26c839cebb2735c6f40ecac970920881942b2ba6d147ce05dc
                    path=2clmi87ali1zc3g856pszfin8aw5jigv/${nixVersion}-aarch64-darwin.tar.xz
                    system=aarch64-darwin
                    ;;
                *) oops "sorry, there is no binary distribution of Nix for your platform";;
            esac

            # Use this command-line option to fetch the tarballs using nar-serve or Cachix
            if [ "\${1:-}" = "--tarball-url-prefix" ]; then
                if [ -z "\${2:-}" ]; then
                    oops "missing argument for --tarball-url-prefix"
                fi
                url=\${2}/\${path}
                shift 2
            else
                url=${urlSource}/${nixVersion}-$system.tar.xz
            fi

            tarball=$tmpDir/${nixVersion}-$system.tar.xz

            require_util tar "unpack the binary tarball"
            if [ "$(uname -s)" != "Darwin" ]; then
                require_util xz "unpack the binary tarball"
            fi

            if command -v curl > /dev/null 2>&1; then
                fetch() { curl --fail -L "$1" -o "$2"; }
            elif command -v wget > /dev/null 2>&1; then
                fetch() { wget "$1" -O "$2"; }
            else
                oops "you don't have wget or curl installed, which I need to download the binary tarball"
            fi

            echo "downloading ${nixVersion} binary tarball for $system from '$url' to '$tmpDir'..."
            fetch "$url" "$tarball" || oops "failed to download '$url'"

            if command -v sha256sum > /dev/null 2>&1; then
                hash2="$(sha256sum -b "$tarball" | cut -c1-64)"
            elif command -v shasum > /dev/null 2>&1; then
                hash2="$(shasum -a 256 -b "$tarball" | cut -c1-64)"
            elif command -v openssl > /dev/null 2>&1; then
                hash2="$(openssl dgst -r -sha256 "$tarball" | cut -c1-64)"
            else
                oops "cannot verify the SHA-256 hash of '$url'; you need one of 'shasum', 'sha256sum', or 'openssl'"
            fi

            if [ "$hash" != "$hash2" ]; then
                oops "SHA-256 hash mismatch in '$url'; expected $hash, got $hash2"
            fi

            unpack=$tmpDir/unpack
            mkdir -p "$unpack"
            tar -xJf "$tarball" -C "$unpack" || oops "failed to unpack '$url'"

            script=$(echo "$unpack"/*/install)

            [ -e "$script" ] || oops "installation script is missing from the binary tarball!"
            export INVOKED_FROM_INSTALL_IN=1
            "$script" "$@"

            } # End of wrapping
        `

        if (OperatingSystem.commonChecks.isWindows) {
            throw Error(`\n\nWindows isn't directly supported, but if you install WSL then it should work.\nHere's a tutorial link for installing WSL Ubuntu: https://www.youtube.com/watch?v=EwRVswCtmX4\n\n`)
            // TODO: auto check for WSL and if it's available, try to automatically enter WSL and run this script again inside of it
        }

        // 
        // fix the windows WSL mkfifo problem
        // 
        const mountCInfo = await FileSystem.info('/mnt/c')
        if (mountCInfo.isFolder) {
            // 
            // check for mounting with metadata
            // 

            // check if metadata not enabled
            const result = await run("mount", "-l", Stdout(returnAsString))
            if (!result.match(/C: on \/mnt\/c.*metadata/)) {
                console.log('__________________________________________________________________________________')
                console.log('|                                                                                |')
                console.log('|  Howdy!                                                                        |')
                console.log('|                                                                                |')
                console.log('|  Looks like there`s a metadata hiccup/problem. It seems you`re using WSL       |')
                console.log('|  Sadly, for some reason, WSL doesn`t (by default) support many features of the |')
                console.log('|  linux file system. And for some reason, adding that support requires          |')
                console.log('|  re-mounting the C drive (within WSL) with metadata enabled.                   |')
                console.log('|                                                                                |')
                console.log('|  I`ll run the command automatically, but if you don`t want to put              |')
                console.log('|  your password in, cancel this (CTRL+C) and run the following yourself:        |')
                console.log('|                                                                                |')
                console.log('       cd                                                                         ')
                console.log('       sudo umount /mnt/c && sudo mount -t drvfs C: /mnt/c -o metadata            ')
                console.log('       cd -                                                                       ')
                console.log('|                                                                                |')
                console.log('|  Then re-run this script                                                       |')
                console.log('|  You can read more about this problem here if you like:                        |')
                console.log('|  https://devblogs.microsoft.com/commandline/chmod-chown-wsl-improvements/      |')
                console.log('|                                                                                |')
                console.log('----------------------------------------------------------------------------------')
                console.log('')
                await Console.askFor.confirmation('Continue?')
                // this means we need to unmount and remount with metadata enabled
                const originalDirectory = FileSystem.pwd
                Deno.chdir(FileSystem.home)
                var { success } = await run("sudo", "umount", "/mnt/c").outcome
                var { success } = success ? await run("sudo", "mount", "-t", "drvfs", "C:", "/mnt/c", "-o", "metadata").outcome : { success }
                // TODO: add a check for an error ^here
                if (!success) {
                    console.error('\nOne of the commands didn`t work :/\ntry running the commands mentioned above manually\n')
                    await Console.askFor.confirmation('Continue anyways?')
                }
                
                // go back
                Deno.chdir(originalDirectory)
            }
            
            // 
            // check if project is inside the windows C drive
            // 
            if (FileSystem.thisFolder.match(/^\/mnt\/c/)) {
                console.log('__________________________________________________________________________________')
                console.log('|                                                                                |')
                console.log('|  Howdy!                                                                        |')
                console.log('|                                                                                |')
                console.log('|  Looks like your project is saved in the windows file system                   |')
                console.log('|  (instead of the Linux/WSL file system)                                        |')
                console.log('|                                                                                |')
                console.log('|  This is a bit of a problem since the file systems of                          |')
                console.log('|  Linux/Mac/Android/ChromeBook/OpenBSD/etc have many features                   |')
                console.log('|  that the windows file system does not.                                        |')
                console.log('|                                                                                |')
                console.log('|  Would it be okay if I move this project?                                      |')
                console.log('|      I`ll create a shortcut to it in the windows folder so you can find it.    |')
                console.log('|      https://devblogs.microsoft.com/commandline/chmod-chown-wsl-improvements/  |')
                console.log('|                                                                                |')
                console.log('----------------------------------------------------------------------------------')
                const answeredYes = await Console.askFor.yesNo("[y/n]")
                if (!answeredYes) {
                    console.log()
                    console.log('okay, in that case just re-run this command whenever')
                    console.log('you have moved the project to the linux file system')
                    console.log('    ')
                    console.log('    if youre confused about what that^ means')
                    console.log('    take a look at the "documentation" folder (inside of this project folder)')
                    console.log()
                    Deno.exit()
                } else {
                    // 
                    // where to move project
                    // 
                    let newProjectLocation, answeredYes
                    while (true) {
                        newProjectLocation = `${FileSystem.home}/repos/${projectName}`
                        answeredYes = await Console.askFor.yesNo(`Is it okay if I move the project to: ${yellow`${newProjectLocation}`}?`)
                        if (!answeredYes) {
                            console.log()
                            newProjectLocation = await Console.askFor.line("Okay what folder should I move it to? ")
                        } else {
                            break
                        }
                    }
                    // 
                    // move the project
                    // 
                    await FileSystem.move({
                        item: virkshop.pathTo.project,
                        newParentFolder: newProjectLocation,
                    })
                    // create a link from the old location to the new location so they can still access the project
                    await FileSystem.relativeLink({
                        existingItem: newProjectLocation,
                        newItem: virkshop.pathTo.project,
                    })
                    virkshop.pathTo.project = newProjectLocation
                }
            }
        }

        // 
        // if nix not installed
        // 
        let nixStoreFolderInfo = await FileSystem.info(`/nix/store`)
        if (!nixStoreFolderInfo.isFolder) {
            console.log("|------------------------------------------------------|")
            console.log("|                                                      |")
            console.log("|    I'll try to install nix for you                   |")
            console.log("|    (since I don't see nix yet)                       |")
            console.log("|                                                      |")
            console.log("|------------------------------------------------------|")
            console.log("")
            // check if root user
            const username = await run`whoami ${Stdout(returnAsString)}`
            if (username == "root") {
                console.log("looks like you're logged in as root")
                console.log("Sadly nix can't install on the root user :/ ")
                console.log("please use a regular user, then re-run this script")
                Deno.exit()
                // TODO: check the available users for whoever is trying to setup as root
            }

            if (OperatingSystem.commonChecks.isMac) {
                // make sure xcode tools are installed
                let result = await run("xcode-select", "--install", Out(returnAsString))
                while (!result.match("already installed")) {
                    await Console.askFor.confirmation("XCode commandline tools dont seem to be installed\nI'm going to send you a prompt to install it okay?")
                    result = await run("xcode-select", "--install", Out(returnAsString))
                }
                // alternative for no-prompt installation:
                    // xcode-select -p &> /dev/null
                    // if [ $? -ne 0 ]; then
                    //     echo "Command Line Tools for Xcode not found. Installing from softwareupdate…"
                    //     # This temporary file prompts the 'softwareupdate' utility to list the Command Line Tools
                    //     echo 
                    //     echo "This is probably going to take 5-30min to install" 
                    //     touch /tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress;
                    //     PROD=$(softwareupdate -l | grep "\*.*Command Line" | tail -n 1 | sed 's/^[^C]* //')
                    //     softwareupdate -i "$PROD" --verbose;
                    // else
                    //     echo "Command Line Tools for Xcode have been installed."
                    // fi
                
                const version = await run`sw_vers -productVersion ${Stdout(returnAsString)}`
                const versionMatch = version.match(/([0-9]+)\.([0-9]+)\.([0-9]+)?/g)
                let [majorVersion, minorVersion, patchVersion] = [ 12, 4, 0 ]
                if (!versionMatch) {
                    console.log(red`There was a bit of a problem :/                                         `)
                    console.log(`---------------------------------------------------------------------------`)
                    console.log(`     I ran this command:  sw_vers -productVersion                          `)
                    console.log(`                                                                           `)
                    console.log(`     Which should return the MacOS version                                 `)
                    console.log(`     And it should be in the format [number].[number].[number]             `)
                    console.log(`     But it appears this is not the case, instead it returned this:        `)
                    console.log(`         ${version}                                                        `)
                    console.log(`     And this script doesn't know how to handle that                       `)
                    console.log(`     Report the issue to the virkshop github repo (google)                 `)
                    console.log(`     And I'll get it fixed ASAP                                            `)
                    console.log(`---------------------------------------------------------------------------`)
                    console.log(``)
                    await Console.askFor.confirmation(`Continue anyways? (I'll assume you have MacOS Monterey)`)
                } else {
                    majorVersion = versionMatch[1]-0
                    minorVersion = versionMatch[2]-0
                    patchVersion = versionMatch[3]-0 || 0 // convert NaN to 0 if needed
                }
                
                // Catalina, Big Sur, Monterey, and beyond
                if (majorVersion > 10 || (majorVersion == 10 && minorVersion >= 15)) {
                    var { success } = await run`bash -c ${`yes | bash <(curl -Lk ${urlSource}/install) --darwin-use-unencrypted-nix-store-volume`}`
                    if (!success) {
                        // fallback
                        var { success } = await run`bash -c ${`bash <(curl -L https://nixos.org/nix/install)`}`
                    }
                // Older than Catalina (Mojave, High Siera, Siera, Yosemite, Mavericks, etc)
                } else {
                    var { success } = await run`curl -Lk ${urlSource}/install | sh -s -- --daemon`
                }

            } else if (OperatingSystem.commonChecks.isLinux) {
                var nixScript
                try {
                    nixScript = await curlString`${urlSource}/install`
                // if host is down, or fails for some other reason, use the locally stored copy (which may be out of date)
                } catch (error) {
                    nixScript = nixScriptLocalCopy
                }
                
                if (await hasCommand("pidof")) {
                    var { success } = await run`pidof systemd`
                    if (success) {
                        await run`bash -c ${`yes | bash <(curl -Lk ${urlSource}/install) --daemon`}`
                    } else {
                        // fallback on single user installation
                        await run("sh", "-s", Stdin(nixScript))
                    }
                } else {
                    // fallback on single user installation
                    await run("sh", "-s", Stdin(nixScript))
                }
            }
        }

        nixStoreFolderInfo = await FileSystem.info(`/nix/store`)
        if (!nixStoreFolderInfo.isFolder) {
            console.log(red`There was a bit of a problem :/                                         `)
            console.log(`---------------------------------------------------------------------------`)
            console.log(`     Something is wrong with the nix install since /nix/store              `)
            console.log(`     is not a folder. It could be a simple fix, so checkout                `)
            console.log(`     https://nixos.org/manual/nix/stable/#chap-installation                `)
            console.log(`     and see if you can follow the normal instructions for installing nix  `)
            console.log(`---------------------------------------------------------------------------`)
            console.log(``)
            await Console.askFor.confirmation('Continue without nix? (basically everything will break)')
        }
    }
    async function sourceNixSetup() {
        // 
        // add nix certificate file
        // 
            // make sure MacOS has cert files
            const certFilePath = "/etc/ssl/certs/ca-certificates.crt"
            const certParentFolder = FileSystem.parentPath(certFilePath)
            const certFileInfo = await FileSystem.info(certFilePath)
            if (!certFileInfo.isFile) {
                const certParentFolderInfo = await FileSystem.info(certFilePath)
                if (!certParentFolderInfo.isFolder) {
                    console.log("")
                    console.log("Creating folder for web certificates because MacOS doesn't follow other OS's")
                    console.log("")
                    await run`sudo mkdir -p ${FileSystem.parentPath(certFilePath)}`
                }
                console.log("")
                console.log("Creating certificate file because MacOS doesn't follow other OS's")
                console.log("")
                await run`sudo security export -t certs -f pemseq -k /System/Library/Keychains/SystemRootCertificates.keychain -o /etc/ssl/certs/ca-certificates.crt`
                // TODO: add a check encase /System/Library/Keychains/SystemRootCertificates.keychain doesnt exist
            }
            
            // 
            // test and check
            // 
            const possibleCertificateLocations = [
                "/etc/ssl/certs/ca-certificates.crt", // NixOS, Ubuntu, Debian, Gentoo, Arch
                "/etc/ssl/ca-bundle.pem",             // openSUSE Tumbleweed
                "/etc/ssl/certs/ca-bundle.crt",       // Old NixOS
                "/etc/pki/tls/certs/ca-bundle.crt",   // Fedora, CentOS
            ]
            for (const eachCertificatePath of possibleCertificateLocations) {
                const file = await FileSystem.info(eachCertificatePath)
                if (file.isFile) {
                    Console.env.NIX_SSL_CERT_FILE = eachCertificatePath
                }
            }
        // 
        // nix profiles
        // 
            Console.env.NIX_PROFILES = `/nix/var/nix/profiles/default ${OperatingSystem.home}/.nix-profile`
        // 
        // nix path
        // 
            Console.env.NIX_PATH = "nixpkgs=/nix/var/nix/profiles/per-user/root/channels/nixpkgs:/nix/var/nix/profiles/per-user/root/channels"
        // 
        // add nix commands
        // 
            Console.env.PATH = `${Console.env.PATH}:${OperatingSystem.home}/.nix-profile/bin/:/nix/var/nix/profiles/default/bin/`
    }

    // 
    // 
    // Nix should now be installed => Enter the virkshop!
    // 
    // 
    async function enterVirkshop() {
        // summary
        const mixinPaths = await FileSystem.listPathsIn(virkshop.pathTo.mixins)
        await virkshop._stages.phase0(mixinPaths) // phase 0: creates/discovers basic virkshop structure (establish linked files/folders, clean broken links)
        await virkshop._stages.phase1(mixinPaths) // phase 1: lets all the mixin's set themselves up (but other mixins are not guarenteed to be setup)
        await virkshop._stages.phase2(mixinPaths) // phase 2: enters the virkshop, and runs zsh login scripts created by the mixins
    }

    async function curlString(url) {
        return  new TextDecoder().decode(
            new Uint8Array(await (await fetch(url)).arrayBuffer())
        )
    }